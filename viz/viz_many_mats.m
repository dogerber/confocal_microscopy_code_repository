function viz_many_mats(manual_zlim)
% takes multiple .mat files generated by tracking_rp3 and shows them next
% to each other

do_save = false;
do_dark = true; % softliv styler used
do_interpolate = false; % interpolates a surface
do_renorm_xy = false; % makes x and y coord start at 0
do_make_flat = false; % if the points are slanted, makes z a relative to flat coordinate
layout = 'rectangle'; % layout of tiles, options: 'sqaure', 'hline','vline','rectangle'
%do_link_axis = true; 

if nargin == 0
manual_zlim = 0;%[22,25]; % set 0 for automatic
end


%% Get Files and prepare them
cd_before = cd;
[filenames, pathname] = uigetfile('*.mat', 'Pick the .mat files here','MultiSelect','on');
if false % sort by _T
    try
    fprintf('Sorting by _T in filename\n');
    Ts = extractBetween(filenames,'_T','_t');
    [~,Tidx]=sort(Ts);
    filenames = filenames(Tidx);
    catch
        fprintf('Sorting by _T failed.')
        filenames = sort(filenames);
    end
else
    filenames = sort(filenames);
end
cd(pathname);



nr_files = length(filenames);

if true

        for i=1:length(filenames)
            fprintf('\t (%d) \t %s \n',i,filenames{i});
        end
end

%% Main part, plot all the mats
f1 = figure;
set(gcf, 'Units', 'Normalized', 'OuterPosition', [0.05, 0.04, 0.5, 0.96]); % make figure big

% --------- Layout  ---------
switch layout
    case 'square' % Square
    grid_width = ceil(sqrt(nr_files));
    grid_height = ceil(nr_files/grid_width);
    case 'rectangle' % Rectangular /manual
    grid_width = round(nr_files/2);
    grid_height = 2;
    case 'vline' % line
    grid_width = 1; %
    grid_height = nr_files;
        case 'hline' % line
    grid_width = nr_files; 
    grid_height = 1;
    otherwise
        error('Layout specifier not recognized.')
end

% custom overwrite
if false
   fprintf('Manual grid ACTIVE.\n') 
   grid_width = 2;
   grid_height = 5;
end

hAx=gobjects(nr_files,1);        % preallocate for the axes handles
zlim_matrix = zeros(nr_files,2);
pks3_sum = [];
for i=1:nr_files
    load(filenames{i},'pks');
    pks = outliers3_fast(pks); % remove outliers roughly
    
    if do_renorm_xy
        fprintf('Renorming z-coordinates to be change relative to flat.\n');
       pks(:,1) = pks(:,1) - min(pks(:,1));
       pks(:,2) = pks(:,2) - min(pks(:,2));
    end
    
    if do_make_flat
      fprintf('Subtracting a plane, converting z to z_relative_to_flat\n');  
    [fitresult, ~] = fit( [pks(:,1), pks(:,2)], pks(:,3), 'poly11' ); % fit plane
    pks(:,3) = pks(:,3)-fitresult(pks(:,1),pks(:,2)); % subtract plane
end
    
    hAx(i)= subplot(grid_height,grid_width,i);
    %distribution3_interpolate(pks);
    %viz_pks(pks); % not interpolated
    if do_interpolate
        distribution3_interpolate(pks);
    else
        local_plotter(pks)
    end
    
    if do_dark
        plot_softliv_style();
    end
    title_text = filenames{i};
    % title_text = extractBetween(title_text,'Position','_40x'); % Adjust this
    title(title_text,'Interpreter','none');
    %legend(filenames{i},'Interpreter','none','Location','best');
    zlim_matrix(i,:) = zlim; % note down z limits for each plot and harmonize them in the end

    pks3_sum = [pks3_sum; pks];

end

% harmonize z-axis
if manual_zlim == 0
    % absolute min and max
min_val = min(zlim_matrix(:,1));
max_val = max(zlim_matrix(:,2));

% 99/1% quantile
%min_val = quantile(pks3_sum,0.01);
%max_val = quantile(pks3_sum,0.99);

% remove 10 from top and bottom
% pks3_sum_sorted = sort(pks3_sum);
% min_val = pks3_sum_sorted(10);
% max_val = pks3_sum_sorted(end-10);

zlim(hAx,[min_val,max_val]);
else
    zlim(hAx, manual_zlim);
end

% harmonize color
if manual_zlim == 0
mean_val = mean(pks3_sum(:,3));
std_val = std(pks3_sum(:,3));
z_bot = quantile(pks3_sum(:,3),0.01);
z_top = quantile(pks3_sum(:,3),0.95);
else
   z_bot = manual_zlim(1);
   z_top = manual_zlim(2);
end

% adjust for all sub-plots
for i=1:nr_files
    %set(hAx(i),'clim',[mean_val-2*std_val, mean_val+2*std_val]); % mean +- 2 std
    set(hAx(i),'clim',[z_bot,z_top]); % quantile as borders
    %set(hAx(i),'clim',[min_val, max_val]); % absolute max and min
    set(hAx(i),'xlim',[min(pks3_sum(:,1)),max(pks3_sum(:,1))]);
     set(hAx(i),'ylim',[min(pks3_sum(:,2)),max(pks3_sum(:,2))]);
     
     % aspect ratio
    set(hAx(i),'PlotBoxAspectRatio',... % sets aspect ratio to be equal only in xy
    [max(pks3_sum(:,1))-min(pks3_sum(:,1)),max(pks3_sum(:,2))-min(pks3_sum(:,2)),...
    2*(max(pks3_sum(:,2))-min(pks3_sum(:,2)))]);
end

 %Link = linkprop(hAx, {'CameraUpVector', 'CameraPosition'});

% Colormap
%colormap winter
%colormap(cbrewer('seq','YlGnBu',20));

% save images with different angles
if do_save && input_YN('Do Save?')
    % save figure
    figname = strcat(string(filenames{1,1}(1:end-4)),'_all.fig');
    savefig(f1,figname);
    
    % save png from specific angles
    angles = [0,0;... % side view along x
        0,90;... % topview
        -30,35]; % angled side, default
    
    for j = 1:length(angles(:,1))
        for i=1:nr_files
            set(hAx(i),'view',angles(j,:));
        end
        filename = strcat(filenames{1},'_angle',num2str(j),'.png');
        export_fig(f1, filename, '-dpng', '-r300', '-transparent');
    end
    fprintf('Files saved.\n');
end

cd(cd_before);
end

%% Functions
function local_plotter(pks)
dot_size = 30;
scatter3(pks(:,1),pks(:,2),pks(:,3),dot_size,pks(:,3),'.',...
    'MarkerFaceAlpha',0.5,'MarkerEdgeAlpha',0.5);
% set(gca,'PlotBoxAspectRatio',... % sets aspect ratio to be equal only in xy
%     [max(pks(:,1))-min(pks(:,1)),max(pks(:,2))-min(pks(:,2)),2*(max(pks(:,2))-min(pks(:,2)))]);
%axis vis3d
end